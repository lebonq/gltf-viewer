Index: src/ViewerApplication.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ViewerApplication.hpp\"\n\n#include <iostream>\n\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include <utility>\n\n#include \"Data.hpp\"\n#include \"utils/cameras.hpp\"\n#include \"utils/gltf.hpp\"\n#include \"utils/images.hpp\"\n\n#include <stb_image_write.h>\n#include <tiny_gltf.h>\n\nvoid keyCallback(\n    GLFWwindow *window, int key, int scancode, int action, int mods)\n{\n  if (key == GLFW_KEY_ESCAPE && action == GLFW_RELEASE) {\n    glfwSetWindowShouldClose(window, 1);\n  }\n}\n\nint ViewerApplication::run()\n{\n  // Loader shaders\n  m_glslProgram_shadowMap =\n      compileProgram({m_ShadersRootPath / \"simpleDepthShader.vs.glsl\",\n          m_ShadersRootPath / \"simpleDepthShader.fs.glsl\"});\n  m_glslProgram_shadowMap.setUniform();\n  m_glslProgram_fullRender =\n      compileProgram({m_ShadersRootPath / \"shadowMapShader.vs.glsl\",\n          m_ShadersRootPath / \"pbr_directional_light_shadows.fs.glsl\"});\n  m_glslProgram_fullRender.setUniform();\n\n  m_glslProgram_normalRender =\n      compileProgram({m_ShadersRootPath / \"forward.vs.glsl\",\n          m_ShadersRootPath / \"normals.fs.glsl\"});\n  m_glslProgram_normalRender.setUniform();\n\n  m_glslProgram_noShadow =\n      compileProgram({m_ShadersRootPath / \"shadowMapShader.vs.glsl\",\n          m_ShadersRootPath / \"pbr_directional_light.fs.glsl\"});\n  m_glslProgram_noShadow.setUniform();\n\n  m_glslProgram_debugShadowMap =\n      compileProgram({m_ShadersRootPath / \"shadowMapShader.vs.glsl\",\n          m_ShadersRootPath / \"debug.fs.glsl\"});\n  m_glslProgram_debugShadowMap.setUniform();\n\n  m_glslProgram_shadowMapRendered = &m_glslProgram_shadowMap;\n  m_glslProgram_rendered = &m_glslProgram_fullRender;\n\n  glm::vec3 lightDir = glm::vec3(1.0f, 1.0f, 1.0f);\n  {\n    const auto sinPhi = glm::sin(lightPhi);\n    const auto cosPhi = glm::cos(lightPhi);\n    const auto sinTheta = glm::sin(lightTheta);\n    const auto cosTheta = glm::cos(lightTheta);\n    lightDir = glm::vec3(sinTheta * cosPhi, cosTheta, sinTheta * sinPhi);\n  }\n  glm::vec3 lightInt = glm::vec3(1.0f, 1.0f, 1.0f);\n  bool lightFromCamera = false;\n  bool applyOcclusion = true;\n  bool renderShadow = true;\n  bool shadowNeedUpdate = true;\n\n  // Build projection matrix\n  std::cerr << \"Load model\" << this->m_gltfFilePath << std::endl;\n  tinygltf::Model model;\n  if (!loadGltfFile(model)) {\n    return -1;\n  }\n  std::cerr << \"Loaded\" << std::endl;\n\n  computeSceneBounds(model, m_bboxMin, m_bboxMax);\n\n  const auto diag = m_bboxMax - m_bboxMin;\n  auto maxDistance = glm::length(diag);\n\n  const auto projMatrix =\n      glm::perspective(70.f, float(m_nWindowWidth) / float(m_nWindowHeight),\n          0.001f * maxDistance, 1.5f * maxDistance);\n\n  std::unique_ptr<CameraController> cameraController =\n      std::make_unique<TrackballCameraController>(\n          m_GLFWHandle.window(), 0.5f * maxDistance);\n  if (m_hasUserCamera) {\n    cameraController->setCamera(m_userCamera);\n  } else {\n    const auto center = 0.5f * (m_bboxMax + m_bboxMin);\n    const auto up = glm::vec3(0, 1, 0);\n    const auto eye =\n        diag.z > 0 ? center + diag : center + 2.f * glm::cross(diag, up);\n    cameraController->setCamera(Camera{eye, center, up});\n  }\n\n  std::cerr << \"Load texture\" << std::endl;\n  auto textureObjects = createTextureObjects(model);\n  std::cerr << \"Loadded\" << std::endl;\n\n  GLuint whiteTexture = 0;\n\n  // Create white texture for object with no base color texture\n  glGenTextures(1, &whiteTexture);\n  glBindTexture(GL_TEXTURE_2D, whiteTexture);\n  float white[] = {1, 1, 1, 1};\n  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT, white);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_REPEAT);\n  glBindTexture(GL_TEXTURE_2D, 0);\n\n  createShadowMap();\n\n  std::cerr << \"Create Buffer Objects\" << std::endl;\n  auto v_bufferObjects = createBufferObjects(model);\n  std::cerr << \"Created\" << std::endl;\n\n  std::cerr << \"Create Vertex Array Objects\" << std::endl;\n  std::vector<VaoRange> v_meshToVertexArrays;\n  const auto vertexArrayObjects =\n      createVertexArrayObjects(model, v_bufferObjects, v_meshToVertexArrays);\n  std::cerr << \"Created\" << std::endl;\n\n  // Setup OpenGL state for rendering\n  glEnable(GL_DEPTH_TEST);\n\n  // Lambda function to bind material\n  const auto bindMaterial = [&](const auto materialIndex,\n                                const GLProgram* shader) {\n    if (materialIndex >= 0) {\n      const auto &material = model.materials[materialIndex];\n      const auto &pbrMetallicRoughness = material.pbrMetallicRoughness;\n      if (shader->m_uBaseColorFactor >= 0) {\n        glUniform4f(shader->m_uBaseColorFactor,\n            (float)pbrMetallicRoughness.baseColorFactor[0],\n            (float)pbrMetallicRoughness.baseColorFactor[1],\n            (float)pbrMetallicRoughness.baseColorFactor[2],\n            (float)pbrMetallicRoughness.baseColorFactor[3]);\n      }\n\n      if (shader->m_uBaseColorTexture >= 0) {\n        auto textureObject = whiteTexture;\n        if (pbrMetallicRoughness.baseColorTexture.index >= 0) {\n          const auto &texture =\n              model.textures[pbrMetallicRoughness.baseColorTexture.index];\n          if (texture.source >= 0) {\n            textureObject = textureObjects[texture.source];\n          }\n        }\n\n        glActiveTexture(GL_TEXTURE0);\n        glBindTexture(GL_TEXTURE_2D, textureObject);\n        glUniform1i(shader->m_uBaseColorTexture, 0);\n      }\n      if (shader->m_uMetallicFactor >= 0) {\n        glUniform1f(shader->m_uMetallicFactor,\n            (float)pbrMetallicRoughness.metallicFactor);\n      }\n      if (shader->m_uRoughnessFactor >= 0) {\n        glUniform1f(shader->m_uRoughnessFactor,\n            (float)pbrMetallicRoughness.roughnessFactor);\n      }\n      if (shader->m_uMetallicRoughnessTexture >= 0) {\n        auto textureObject = 0u;\n        if (pbrMetallicRoughness.metallicRoughnessTexture.index >= 0) {\n          const auto &texture =\n              model.textures[pbrMetallicRoughness.metallicRoughnessTexture\n                                 .index];\n          if (texture.source >= 0) {\n            textureObject = textureObjects[texture.source];\n          }\n        }\n\n        glActiveTexture(GL_TEXTURE1);\n        glBindTexture(GL_TEXTURE_2D, textureObject);\n        glUniform1i(shader->m_uMetallicRoughnessTexture, 1);\n      }\n      if (shader->m_uEmissiveFactor >= 0) {\n        glUniform3f(shader->m_uEmissiveFactor, (float)material.emissiveFactor[0],\n            (float)material.emissiveFactor[1],\n            (float)material.emissiveFactor[2]);\n      }\n      if (shader->m_uEmissiveTexture >= 0) {\n        auto textureObject = 0u;\n        if (material.emissiveTexture.index >= 0) {\n          const auto &texture = model.textures[material.emissiveTexture.index];\n          if (texture.source >= 0) {\n            textureObject = textureObjects[texture.source];\n          }\n        }\n\n        glActiveTexture(GL_TEXTURE2);\n        glBindTexture(GL_TEXTURE_2D, textureObject);\n        glUniform1i(shader->m_uEmissiveTexture, 2);\n      }\n      if (shader->m_uOcclusionStrength >= 0) {\n        glUniform1f(shader->m_uOcclusionStrength,\n            (float)material.occlusionTexture.strength);\n      }\n      if (shader->m_uOcclusionTexture >= 0) {\n        auto textureObject = whiteTexture;\n        if (material.occlusionTexture.index >= 0) {\n          const auto &texture = model.textures[material.occlusionTexture.index];\n          if (texture.source >= 0) {\n            textureObject = textureObjects[texture.source];\n          }\n        }\n\n        glActiveTexture(GL_TEXTURE3);\n        glBindTexture(GL_TEXTURE_2D, textureObject);\n        glUniform1i(shader->m_uOcclusionTexture, 3);\n      }\n\n    } else {\n      // Apply default material\n      // Defined here:\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#reference-material\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#reference-pbrmetallicroughness3\n      if (shader->m_uBaseColorFactor >= 0) {\n        glUniform4f(shader->m_uBaseColorFactor, 1, 1, 1, 1);\n      }\n\n      if (shader->m_uBaseColorTexture >= 0) {\n        glActiveTexture(GL_TEXTURE0);\n        glBindTexture(GL_TEXTURE_2D, 0);\n        glUniform1i(shader->m_uBaseColorTexture, (GLint)whiteTexture);\n      }\n      if (shader->m_uMetallicFactor >= 0) {\n        glUniform1f(shader->m_uMetallicFactor, 1.f);\n      }\n      if (shader->m_uRoughnessFactor >= 0) {\n        glUniform1f(shader->m_uRoughnessFactor, 1.f);\n      }\n      if (shader->m_uMetallicRoughnessTexture >= 0) {\n        glActiveTexture(GL_TEXTURE1);\n        glBindTexture(GL_TEXTURE_2D, 0);\n        glUniform1i(shader->m_uMetallicRoughnessTexture, 1);\n      }\n      if (shader->m_uEmissiveFactor >= 0) {\n        glUniform3f(shader->m_uEmissiveFactor, 0.f, 0.f, 0.f);\n      }\n      if (shader->m_uEmissiveTexture >= 0) {\n        glActiveTexture(GL_TEXTURE2);\n        glBindTexture(GL_TEXTURE_2D, 0);\n        glUniform1i(shader->m_uEmissiveTexture, 2);\n      }\n      if (shader->m_uOcclusionStrength >= 0) {\n        glUniform1f(shader->m_uOcclusionStrength, 0.f);\n      }\n      if (shader->m_uOcclusionTexture >= 0) {\n        glActiveTexture(GL_TEXTURE3);\n        glBindTexture(GL_TEXTURE_2D, 0);\n        glUniform1i(shader->m_uOcclusionTexture, 3);\n      }\n    }\n  };\n\n  // Lambda function to draw the scene\n  const auto drawScene = [&](glm::mat4 viewMatrix, const GLProgram* shader) {\n    // The recursive function that should draw a node\n    // We use a std::function because a simple lambda cannot be recursive\n    const std::function<void(int, const glm::mat4 &)> drawNode =\n        [&](int nodeIdx, const glm::mat4 &parentMatrix) {\n          auto v_node = model.nodes[nodeIdx];\n          glm::mat4 modelMatrix = getLocalToWorldMatrix(v_node, parentMatrix);\n          if (v_node.mesh >= 0) {\n            // send model matrix\n            if (shader->m_uModelMatrixLocation >= 0) {\n              glUniformMatrix4fv(shader->m_uModelMatrixLocation, 1, GL_FALSE,\n                  glm::value_ptr(modelMatrix));\n            }\n\n            if (shader->m_ulightDirection >= 0) {\n              if (lightFromCamera) {\n                glUniform3f(shader->m_ulightDirection, 0, 0, 1);\n              } else {\n                const auto lightDirectionInViewSpace = glm::normalize(\n                    glm::vec3(viewMatrix * glm::vec4(lightDir, 0.)));\n                glUniform3f(shader->m_ulightDirection,\n                    lightDirectionInViewSpace[0], lightDirectionInViewSpace[1],\n                    lightDirectionInViewSpace[2]);\n              }\n            }\n            if (shader->m_ulightIntensity >= 0) {\n              glUniform3fv(\n                  shader->m_ulightIntensity, 1, glm::value_ptr(lightInt));\n            }\n            if (shader->m_uApplyOcclusion >= 0) {\n              glUniform1i(shader->m_uApplyOcclusion, applyOcclusion);\n            }\n\n            // get mesh an draw every primitives\n            auto v_mesh = model.meshes[v_node.mesh];\n            auto v_vaoRange = v_meshToVertexArrays[v_node.mesh];\n\n            for (int i = 0; i < v_mesh.primitives.size(); ++i) {\n              auto v_vao = vertexArrayObjects[v_vaoRange.begin + i];\n              auto primitive = v_mesh.primitives[i];\n              bindMaterial(primitive.material, shader);\n              glBindVertexArray(v_vao);\n              if (primitive.indices >= 0) {\n                const auto &accessor = model.accessors[primitive.indices];\n                const auto &bufferView = model.bufferViews[accessor.bufferView];\n                const auto byteOffset =\n                    accessor.byteOffset + bufferView.byteOffset;\n                glDrawElements(primitive.mode, GLsizei(accessor.count),\n                    accessor.componentType, (const GLvoid *)byteOffset);\n\n              } else {\n                // Take first accessor to get the count\n                const auto accessorIdx = (*begin(primitive.attributes)).second;\n                const auto &accessor = model.accessors[accessorIdx];\n                glDrawArrays(primitive.mode, 0, GLsizei(accessor.count));\n              }\n            }\n          }\n          for (auto v_child : v_node.children) {\n            drawNode(v_child, parentMatrix);\n          }\n        };\n\n    // Draw the scene referenced by gltf file\n    if (model.defaultScene >= 0) {\n      for (auto node : model.scenes[model.defaultScene].nodes) {\n        drawNode(node, glm::mat4(1));\n      }\n    }\n  };\n\n  const auto computeShadowMap = [&]() {\n    const auto sceneCenter = 0.5f * (m_bboxMin + m_bboxMax);\n    const float sceneRadius = glm::length((m_bboxMax - m_bboxMin)) * 0.5f;\n\n    glm::mat4 dirLightViewMatrix = glm::mat4(0);\n\n    if(lightFromCamera){ // compute the shadow from the camera\n      const auto cam = cameraController->getCamera();\n      dirLightViewMatrix = glm::lookAt(cam.eye(),cam.center(),cam.up());\n    }else //Compute the shadow as a distant light\n      {\n        const auto dirLightUpVector =\n            computeDirectionVectorUp(lightPhi, lightTheta);\n\n        dirLightViewMatrix = glm::lookAt(sceneCenter + lightDir * sceneRadius, sceneCenter,\n                dirLightUpVector); // Will not work if m_DirLightDirection is\n                                   // colinear to lightUpVector\n    }\n    const auto dirLightProjMatrix = glm::ortho(-sceneRadius, sceneRadius,\n        -sceneRadius, sceneRadius, 0.1f * sceneRadius, 2.f * sceneRadius);\n    m_lightSpaceMatrix = dirLightProjMatrix * dirLightViewMatrix;\n\n    m_glslProgram_shadowMapRendered->use();\n    glUniformMatrix4fv(m_glslProgram_shadowMapRendered->m_uLightSpaceMatrix, 1, GL_FALSE,\n        glm::value_ptr(m_lightSpaceMatrix));\n\n    glEnable(GL_DEPTH_TEST);\n    glViewport(0, 0, SHADOW_RES, SHADOW_RES);\n    glBindFramebuffer(GL_FRAMEBUFFER, m_depthMapFBO);\n    glClear(GL_DEPTH_BUFFER_BIT);\n    drawScene(dirLightViewMatrix, m_glslProgram_shadowMapRendered);\n    glBindFramebuffer(GL_FRAMEBUFFER, 0);\n  };\n\n  const auto render = [&]() {\n    const auto camera = cameraController->getCamera();\n\n    m_glslProgram_rendered->use();\n    const auto viewMatrix = camera.getViewMatrix();\n    if (m_glslProgram_rendered->m_uViewMatrixLocation >= 0) {\n      glUniformMatrix4fv(m_glslProgram_rendered->m_uViewMatrixLocation, 1,\n          GL_FALSE, glm::value_ptr(viewMatrix));\n    }\n    if (m_glslProgram_rendered->m_uProjectionMatrixLocation >= 0) {\n      glUniformMatrix4fv(m_glslProgram_rendered->m_uProjectionMatrixLocation, 1,\n          GL_FALSE, glm::value_ptr(projMatrix));\n    }\n    glUniformMatrix4fv(m_glslProgram_rendered->m_uLightSpaceMatrix, 1, GL_FALSE,\n        glm::value_ptr(m_lightSpaceMatrix));\n\n    glActiveTexture(GL_TEXTURE4);\n    glBindTexture(GL_TEXTURE_2D, m_depthMap);\n    glUniform1i(m_glslProgram_rendered->m_uDirLightShadowMap, 4);\n\n    glViewport(0, 0, m_nWindowWidth, m_nWindowHeight);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    drawScene(viewMatrix, m_glslProgram_rendered);\n  };\n\n  if (!m_OutputPath.empty()) {\n    std::vector<unsigned char> pixels(m_nWindowWidth * m_nWindowHeight * 3);\n\n    renderToImage(m_nWindowWidth, m_nWindowHeight, 3, pixels.data(), [&]() {\n      render();\n    },[&]() {\n          computeShadowMap();\n        });\n    flipImageYAxis(m_nWindowWidth, m_nWindowHeight, 3, pixels.data());\n    const auto strPath = m_OutputPath.string();\n    stbi_write_png(\n        strPath.c_str(), m_nWindowWidth, m_nWindowHeight, 3, pixels.data(), 0);\n    return 0;\n  }\n\n  // Loop until the user closes the window\n  for (auto iterationCount = 0u; !m_GLFWHandle.shouldClose();\n       ++iterationCount) {\n    const auto seconds = glfwGetTime();\n    const auto camera = cameraController->getCamera();\n\n    if((shadowNeedUpdate || lightFromCamera) && renderShadow) {\n      computeShadowMap();\n      shadowNeedUpdate = false;\n    }\n\n    if(lightFromCamera) shadowNeedUpdate = true;\n    render();\n\n    // GUI code:\n    imguiNewFrame();\n\n    {\n      ImGui::Begin(\"GUI\");\n      ImGui::Text(\"Application average %.3f ms/frame (%.1f FPS)\",\n          1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);\n      if (ImGui::CollapsingHeader(\"Camera\", ImGuiTreeNodeFlags_DefaultOpen)) {\n        ImGui::Text(\"eye: %.3f %.3f %.3f\", camera.eye().x, camera.eye().y,\n            camera.eye().z);\n        ImGui::Text(\"center: %.3f %.3f %.3f\", camera.center().x,\n            camera.center().y, camera.center().z);\n        ImGui::Text(\n            \"up: %.3f %.3f %.3f\", camera.up().x, camera.up().y, camera.up().z);\n\n        ImGui::Text(\"front: %.3f %.3f %.3f\", camera.front().x, camera.front().y,\n            camera.front().z);\n        ImGui::Text(\"left: %.3f %.3f %.3f\", camera.left().x, camera.left().y,\n            camera.left().z);\n\n        if (ImGui::Button(\"CLI camera args to clipboard\")) {\n          std::stringstream ss;\n          ss << \"--lookat \" << camera.eye().x << \",\" << camera.eye().y << \",\"\n             << camera.eye().z << \",\" << camera.center().x << \",\"\n             << camera.center().y << \",\" << camera.center().z << \",\"\n             << camera.up().x << \",\" << camera.up().y << \",\" << camera.up().z;\n          const auto str = ss.str();\n          glfwSetClipboardString(m_GLFWHandle.window(), str.c_str());\n        }\n      }\n      static int cameraControllerType = 0;\n      auto cameraControllerTypeChanged =\n          ImGui::RadioButton(\"Trackball\", &cameraControllerType, 0) ||\n          ImGui::RadioButton(\"First Person\", &cameraControllerType, 1);\n      if (cameraControllerTypeChanged) {\n        const auto currentCamera = cameraController->getCamera();\n        if (cameraControllerType == 0) {\n          cameraController = std::make_unique<TrackballCameraController>(\n              m_GLFWHandle.window(), 0.5f * maxDistance);\n        } else {\n          cameraController = std::make_unique<FirstPersonCameraController>(\n              m_GLFWHandle.window(), 0.5f * maxDistance);\n        }\n        cameraController->setCamera(currentCamera);\n      }\n\n      if (ImGui::CollapsingHeader(\"Light\", ImGuiTreeNodeFlags_DefaultOpen)) {\n\n        if (ImGui::SliderFloat(\"theta\", &lightTheta, 0, glm::pi<float>()) ||\n            ImGui::SliderFloat(\"phi\", &lightPhi, 0, 2.f * glm::pi<float>())) {\n          const auto sinPhi = glm::sin(lightPhi);\n          const auto cosPhi = glm::cos(lightPhi);\n          const auto sinTheta = glm::sin(lightTheta);\n          const auto cosTheta = glm::cos(lightTheta);\n          lightDir = glm::vec3(sinTheta * cosPhi, cosTheta, sinTheta * sinPhi);\n          shadowNeedUpdate = true; //If light direction changed, shadow map need update\n        }\n\n        static glm::vec3 lightColor(1.f, 1.f, 1.f);\n        static float lightIntensityFactor = 1.f;\n\n        if (ImGui::ColorEdit3(\"color\", (float *)&lightColor) ||\n            ImGui::InputFloat(\"intensity\", &lightIntensityFactor)) {\n          lightInt = lightColor * lightIntensityFactor;\n        }\n      }\n      ImGui::Checkbox(\"light from camera\", &lightFromCamera);\n      ImGui::Checkbox(\"apply occlusion\", &applyOcclusion);\n      if (ImGui::CollapsingHeader(\"Shadow Option\")) {\n        if(ImGui::SliderInt(\"Shadow Resolution\", &SHADOW_RES, 128, 4096*3)){\n          glDeleteFramebuffers(1,&m_depthMapFBO);\n          glDeleteTextures(1,&m_depthMap);\n          createShadowMap();\n          shadowNeedUpdate = true; //If shadow res changed, shadow map need update\n        }\n      }\n      if (ImGui::CollapsingHeader(\"Render Type\")) {\n        static int renderType = 0;\n        auto renderTypeChanged =\n            ImGui::RadioButton(\"Full Render\", &renderType, 0) ||\n            ImGui::RadioButton(\"Normal render\", &renderType, 1) ||\n            ImGui::RadioButton(\"No shadow\", &renderType, 2)||\n            ImGui::RadioButton(\"Shadow Map Render\", &renderType, 3);\n        if (renderTypeChanged) {\n          if (renderType == 0) {\n            m_glslProgram_rendered = &m_glslProgram_fullRender;\n            renderShadow = true;\n\n          } else if (renderType == 1) {\n            m_glslProgram_rendered = &m_glslProgram_normalRender;\n            renderShadow = false;\n\n          } else if (renderType == 2) {\n            m_glslProgram_rendered = &m_glslProgram_noShadow;\n            renderShadow = false;\n\n          }\n          else if (renderType == 3) {\n            m_glslProgram_rendered = &m_glslProgram_debugShadowMap;\n            renderShadow = true;\n          }\n        }\n      }\n\n      ImGui::End();\n    }\n\n    imguiRenderFrame();\n\n    glfwPollEvents(); // Poll for and process events\n\n    auto ellapsedTime = glfwGetTime() - seconds;\n    auto guiHasFocus =\n        ImGui::GetIO().WantCaptureMouse || ImGui::GetIO().WantCaptureKeyboard;\n    if (!guiHasFocus) {\n      cameraController->update(float(ellapsedTime));\n    }\n\n    m_GLFWHandle.swapBuffers(); // Swap front and back buffers\n  }\n\n  glDeleteVertexArrays((GLsizei)vertexArrayObjects.size(), vertexArrayObjects.data());\n  glDeleteBuffers((GLsizei)v_bufferObjects.size(), v_bufferObjects.data());\n  glDeleteTextures((GLsizei)textureObjects.size(), textureObjects.data());\n  glDeleteFramebuffers(1, &m_depthMapFBO);\n  glDeleteTextures(1, &m_depthMap);\n\n  return 0;\n}\n\nViewerApplication::ViewerApplication(fs::path appPath, uint32_t width,\n    uint32_t height, const fs::path &gltfFile,\n    const std::vector<float> &lookatArgs, const std::string &vertexShader,\n    const std::string &fragmentShader, const fs::path &output) :\n    m_nWindowWidth((GLsizei)width),\n    m_nWindowHeight((GLsizei)height),\n    m_AppPath{std::move(appPath)},\n    m_AppName{m_AppPath.stem().string()},\n    m_ImGuiIniFilename{m_AppName + \".imgui.ini\"},\n    m_ShadersRootPath{m_AppPath.parent_path() / \"shaders\"},\n    m_gltfFilePath{gltfFile},\n    m_OutputPath{output}\n{\n  if (!lookatArgs.empty()) {\n    m_hasUserCamera = true;\n    m_userCamera =\n        Camera{glm::vec3(lookatArgs[0], lookatArgs[1], lookatArgs[2]),\n            glm::vec3(lookatArgs[3], lookatArgs[4], lookatArgs[5]),\n            glm::vec3(lookatArgs[6], lookatArgs[7], lookatArgs[8])};\n  }\n\n  ImGui::GetIO().IniFilename =\n      m_ImGuiIniFilename.c_str(); // At exit, ImGUI will store its windows\n                                  // positions in this file\n\n  glfwSetKeyCallback(m_GLFWHandle.window(), keyCallback);\n\n  printGLVersion();\n}\n\nbool ViewerApplication::loadGltfFile(tinygltf::Model &model)\n{\n\n  tinygltf::TinyGLTF loader;\n  std::string err;\n  std::string warn;\n  bool ret = loader.LoadASCIIFromFile(&model, &err, &warn, m_gltfFilePath);\n\n  if (!warn.empty()) {\n    printf(\"Warn: %s\\n\", warn.c_str());\n  }\n\n  if (!err.empty()) {\n    printf(\"Err: %s\\n\", err.c_str());\n  }\n\n  return ret;\n}\n\nstd::vector<GLuint> ViewerApplication::createTextureObjects(\n    const tinygltf::Model &model)\n{\n  std::vector<GLuint> textureObjects(model.textures.size(), 0);\n\n  // default sampler:\n  // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#texturesampler\n  // \"When undefined, a sampler with repeat wrapping and auto filtering should\n  // be used.\"\n  tinygltf::Sampler defaultSampler;\n  defaultSampler.minFilter = GL_LINEAR;\n  defaultSampler.magFilter = GL_LINEAR;\n  defaultSampler.wrapS = GL_REPEAT;\n  defaultSampler.wrapT = GL_REPEAT;\n  defaultSampler.wrapR = GL_REPEAT;\n\n  glActiveTexture(GL_TEXTURE0);\n\n  glGenTextures(GLsizei(model.textures.size()), textureObjects.data());\n  for (size_t i = 0; i < model.textures.size(); ++i) {\n    const auto &texture = model.textures[i];\n    assert(texture.source >= 0);\n    const auto &image = model.images[texture.source];\n\n    const auto &sampler =\n        texture.sampler >= 0 ? model.samplers[texture.sampler] : defaultSampler;\n    glBindTexture(GL_TEXTURE_2D, textureObjects[i]);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image.width, image.height, 0,\n        GL_RGBA, image.pixel_type, image.image.data());\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,\n        sampler.minFilter != -1 ? sampler.minFilter : GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,\n        sampler.magFilter != -1 ? sampler.magFilter : GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, sampler.wrapS);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, sampler.wrapT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, sampler.wrapR);\n\n    if (sampler.minFilter == GL_NEAREST_MIPMAP_NEAREST ||\n        sampler.minFilter == GL_NEAREST_MIPMAP_LINEAR ||\n        sampler.minFilter == GL_LINEAR_MIPMAP_NEAREST ||\n        sampler.minFilter == GL_LINEAR_MIPMAP_LINEAR) {\n      glGenerateMipmap(GL_TEXTURE_2D);\n    }\n  }\n  glBindTexture(GL_TEXTURE_2D, 0);\n\n  return textureObjects;\n}\n\nstd::vector<GLuint> ViewerApplication::createBufferObjects(\n    const tinygltf::Model &model)\n{\n\n  std::vector<GLuint> bufferObjects(model.buffers.size(), 0);\n\n  glGenBuffers(GLsizei(bufferObjects.size()), bufferObjects.data());\n\n  for (size_t i = 0; i < model.buffers.size(); ++i) {\n    const auto &buffer = model.buffers[i].data;\n    glBindBuffer(GL_ARRAY_BUFFER, bufferObjects[i]);\n    glBufferStorage(GL_ARRAY_BUFFER,(GLsizei) buffer.size(), buffer.data(), 0);\n  }\n  glBindBuffer(GL_ARRAY_BUFFER, 0);\n\n  return bufferObjects;\n}\n\nstd::vector<GLuint> ViewerApplication::createVertexArrayObjects(\n    const tinygltf::Model &model, const std::vector<GLuint> &bufferObjects,\n    std::vector<VaoRange> &meshIndexToVaoRange)\n{\n\n  std::vector<GLuint> vertexArrayObjects;\n\n  // For each mesh of model we keep its range of VAOs\n  meshIndexToVaoRange.resize(model.meshes.size());\n\n  for (size_t idx_mesh = 0; idx_mesh < model.meshes.size(); ++idx_mesh) {\n    const auto &mesh = model.meshes[idx_mesh];\n\n    auto &vaoRange = meshIndexToVaoRange[idx_mesh];\n    vaoRange.begin =\n        GLsizei(vertexArrayObjects.size()); // Range for this mesh will be at\n                                            // the end of vertexArrayObjects\n    vaoRange.count =\n        GLsizei(mesh.primitives.size()); // One VAO for each primitive\n\n    // Add enough elements to store our VAOs identifiers\n    vertexArrayObjects.resize(\n        vertexArrayObjects.size() + mesh.primitives.size());\n    glGenVertexArrays(vaoRange.count, &vertexArrayObjects[vaoRange.begin]);\n    for (size_t pIdx = 0; pIdx < mesh.primitives.size(); ++pIdx) {\n      const auto vao = vertexArrayObjects[vaoRange.begin + pIdx];\n      const auto &primitive = mesh.primitives[pIdx];\n      glBindVertexArray(vao);\n      //=============== Position ====================\n      { // I'm opening a scope because I want to reuse the variable iterator in\n        // the code for NORMAL and TEXCOORD_0\n        const auto iterator = primitive.attributes.find(\"POSITION\");\n        if (iterator !=\n            end(primitive\n                    .attributes)) { // If \"POSITION\" has been found in the map\n          // (*iterator).first is the key \"POSITION\", (*iterator).second is the\n          // value, ie. the index of the accessor for this attribute\n          const auto accessorIdx = (*iterator).second;\n          const auto &accessor = model.accessors[accessorIdx];\n          const auto &bufferView = model.bufferViews[accessor.bufferView];\n          const auto bufferIdx = bufferView.buffer;\n\n          const auto bufferObject = bufferObjects[bufferIdx];\n\n          glEnableVertexAttribArray(VERTEX_ATTRIB_POSITION_IDX); // Enable array\n          glBindBuffer(GL_ARRAY_BUFFER,\n              bufferObject); // Bind the buffer object to GL_ARRAY_BUFFER\n\n          const auto byteOffset = accessor.byteOffset + bufferView.byteOffset;\n          ; // Compute the total byte offset using the accessor and the buffer\n            // view\n          glVertexAttribPointer(VERTEX_ATTRIB_POSITION_IDX, accessor.type,\n              accessor.componentType, GL_FALSE, GLsizei(bufferView.byteStride),\n              (const GLvoid *)byteOffset);\n        }\n      }\n      //=============== Normal ====================\n      { // I'm opening a scope because I want to reuse the variable iterator in\n        // the code for NORMAL and TEXCOORD_0\n        const auto iterator = primitive.attributes.find(\"NORMAL\");\n        if (iterator !=\n            end(primitive\n                    .attributes)) { // If \"POSITION\" has been found in the map\n          // (*iterator).first is the key \"POSITION\", (*iterator).second is the\n          // value, ie. the index of the accessor for this attribute\n          const auto accessorIdx = (*iterator).second;\n          const auto &accessor = model.accessors[accessorIdx];\n          const auto &bufferView = model.bufferViews[accessor.bufferView];\n          const auto bufferIdx = bufferView.buffer;\n\n          const auto bufferObject = bufferObjects[bufferIdx];\n\n          glEnableVertexAttribArray(VERTEX_ATTRIB_NORMAL_IDX); // Enable array\n          glBindBuffer(GL_ARRAY_BUFFER,\n              bufferObject); // Bind the buffer object to GL_ARRAY_BUFFER\n\n          const auto byteOffset = accessor.byteOffset + bufferView.byteOffset;\n          ; // Compute the total byte offset using the accessor and the buffer\n            // view\n          glVertexAttribPointer(VERTEX_ATTRIB_NORMAL_IDX, accessor.type,\n              accessor.componentType, GL_FALSE, GLsizei(bufferView.byteStride),\n              (const GLvoid *)byteOffset);\n        }\n      }\n      //=============== Texture ====================\n      { // I'm opening a scope because I want to reuse the variable iterator in\n        // the code for NORMAL and TEXCOORD_0\n        const auto iterator = primitive.attributes.find(\"TEXCOORD_0\");\n        if (iterator !=\n            end(primitive\n                    .attributes)) { // If \"POSITION\" has been found in the map\n          // (*iterator).first is the key \"POSITION\", (*iterator).second is the\n          // value, ie. the index of the accessor for this attribute\n          const auto accessorIdx = (*iterator).second;\n          const auto &accessor = model.accessors[accessorIdx];\n          const auto &bufferView = model.bufferViews[accessor.bufferView];\n          const auto bufferIdx = bufferView.buffer;\n\n          const auto bufferObject = bufferObjects[bufferIdx];\n\n          glEnableVertexAttribArray(\n              VERTEX_ATTRIB_TEXCOORD0_IDX); // Enable array\n          glBindBuffer(GL_ARRAY_BUFFER,\n              bufferObject); // Bind the buffer object to GL_ARRAY_BUFFER\n\n          const auto byteOffset = accessor.byteOffset + bufferView.byteOffset;\n          ; // Compute the total byte offset using the accessor and the buffer\n            // view\n          glVertexAttribPointer(VERTEX_ATTRIB_TEXCOORD0_IDX, accessor.type,\n              accessor.componentType, GL_FALSE, GLsizei(bufferView.byteStride),\n              (const GLvoid *)byteOffset);\n        }\n      }\n      // Index array if defined\n      if (primitive.indices >= 0) {\n        const auto accessorIdx = primitive.indices;\n        const auto &accessor = model.accessors[accessorIdx];\n        const auto &bufferView = model.bufferViews[accessor.bufferView];\n        const auto bufferIdx = bufferView.buffer;\n\n        assert(GL_ELEMENT_ARRAY_BUFFER == bufferView.target);\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,\n            bufferObjects[bufferIdx]); // Binding the index buffer to\n                                       // GL_ELEMENT_ARRAY_BUFFER while the VAO\n                                       // is bound is enough to tell OpenGL we\n                                       // want to use that index buffer for that\n                                       // VAO\n      }\n    }\n  }\n  glBindVertexArray(0);\n  std::clog << \"Number of VAOs: \" << vertexArrayObjects.size() << std::endl;\n\n  return vertexArrayObjects;\n}\n\nvoid ViewerApplication::createShadowMap()\n{\n  glGenFramebuffers(1, &m_depthMapFBO);\n  // create depth texture\n  glGenTextures(1, &m_depthMap);\n  glBindTexture(GL_TEXTURE_2D, m_depthMap);\n  glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, SHADOW_RES,\n      SHADOW_RES, 0, GL_DEPTH_COMPONENT, GL_FLOAT, nullptr);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);\n  float borderColor[] = {1.0, 1.0, 1.0, 1.0};\n  glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);\n  // attach depth texture as FBO's depth buffer\n  glBindFramebuffer(GL_FRAMEBUFFER, m_depthMapFBO);\n  glFramebufferTexture2D(\n      GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, m_depthMap, 0);\n  glDrawBuffer(GL_NONE);\n  glReadBuffer(GL_NONE);\n  glBindFramebuffer(GL_FRAMEBUFFER, 0);\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ViewerApplication.cpp b/src/ViewerApplication.cpp
--- a/src/ViewerApplication.cpp	(revision 9f0c7e7233dd62ecbf242a34fa8658ed057f1b53)
+++ b/src/ViewerApplication.cpp	(date 1679788789528)
@@ -24,6 +24,7 @@
 
 int ViewerApplication::run()
 {
+  glEnableVertexAttribArray(0);
   // Loader shaders
   m_glslProgram_shadowMap =
       compileProgram({m_ShadersRootPath / "simpleDepthShader.vs.glsl",
@@ -52,6 +53,8 @@
   m_glslProgram_shadowMapRendered = &m_glslProgram_shadowMap;
   m_glslProgram_rendered = &m_glslProgram_fullRender;
 
+  m_glslProgram_rendered->use();
+
   glm::vec3 lightDir = glm::vec3(1.0f, 1.0f, 1.0f);
   {
     const auto sinPhi = glm::sin(lightPhi);
@@ -129,6 +132,7 @@
   // Setup OpenGL state for rendering
   glEnable(GL_DEPTH_TEST);
 
+
   // Lambda function to bind material
   const auto bindMaterial = [&](const auto materialIndex,
                                 const GLProgram* shader) {
@@ -216,6 +220,20 @@
         glUniform1i(shader->m_uOcclusionTexture, 3);
       }
 
+      if (shader->m_uNormalTexture >= 0) {
+        auto textureObject = whiteTexture;
+        if (material.occlusionTexture.index >= 0) {
+          const auto &texture = model.textures[material.normalTexture.index];
+          if (texture.source >= 0) {
+            textureObject = textureObjects[texture.source];
+          }
+        }
+
+        glActiveTexture(GL_TEXTURE5);//4 is for shadow map
+        glBindTexture(GL_TEXTURE_2D, textureObject);
+        glUniform1i(shader->m_uNormalTexture, 5);
+      }
+
     } else {
       // Apply default material
       // Defined here:
@@ -257,6 +275,11 @@
         glBindTexture(GL_TEXTURE_2D, 0);
         glUniform1i(shader->m_uOcclusionTexture, 3);
       }
+      if (shader->m_uNormalTexture >= 0) {
+        glActiveTexture(GL_TEXTURE5);//4 is for shadow map
+        glBindTexture(GL_TEXTURE_2D, 0);
+        glUniform1i(shader->m_uNormalTexture, 5);
+      }
     }
   };
 
@@ -751,8 +774,7 @@
         }
       }
       //=============== Texture ====================
-      { // I'm opening a scope because I want to reuse the variable iterator in
-        // the code for NORMAL and TEXCOORD_0
+      {
         const auto iterator = primitive.attributes.find("TEXCOORD_0");
         if (iterator !=
             end(primitive
@@ -779,6 +801,34 @@
               (const GLvoid *)byteOffset);
         }
       }
+
+        {
+          const auto iterator = primitive.attributes.find("TANGENT");
+          if (iterator !=
+              end(primitive
+                      .attributes)) { // If "POSITION" has been found in the map
+            // (*iterator).first is the key "POSITION", (*iterator).second is the
+            // value, ie. the index of the accessor for this attribute
+            const auto accessorIdx = (*iterator).second;
+            const auto &accessor = model.accessors[accessorIdx];
+            const auto &bufferView = model.bufferViews[accessor.bufferView];
+            const auto bufferIdx = bufferView.buffer;
+
+            const auto bufferObject = bufferObjects[bufferIdx];
+
+            glEnableVertexAttribArray(
+                VERTEX_ATTRIB_TANGEANT_IDX); // Enable array
+            glBindBuffer(GL_ARRAY_BUFFER,
+                bufferObject); // Bind the buffer object to GL_ARRAY_BUFFER
+
+            const auto byteOffset = accessor.byteOffset + bufferView.byteOffset;
+            ; // Compute the total byte offset using the accessor and the buffer
+              // view
+            glVertexAttribPointer(VERTEX_ATTRIB_TANGEANT_IDX, accessor.type,
+                accessor.componentType, GL_FALSE, GLsizei(bufferView.byteStride),
+                (const GLvoid *)byteOffset);
+          }
+      }
       // Index array if defined
       if (primitive.indices >= 0) {
         const auto accessorIdx = primitive.indices;
Index: src/shaders/shadowMapShader.vs.glsl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#version 330 core\n\nlayout(location = 0) in vec3 aPosition;\nlayout(location = 1) in vec3 aNormal;\nlayout(location = 2) in vec2 aTexCoords;\n\nout vec3 vViewSpacePosition;\nout vec3 vViewSpaceNormal;\nout vec2 vTexCoords;\nout vec4 vFragPosLightSpace;\nout vec3 vFragPos;\n\nuniform mat4 uViewMatrix;\nuniform mat4 uModelMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat4 uLightSpaceMatrix;\n\nvoid main()\n{\n    mat4 vModelViewMatrix = uViewMatrix * uModelMatrix;\n    mat4 vModelViewProjMatrix = uProjectionMatrix * vModelViewMatrix;\n    mat4 vNormalMatrix = transpose(inverse(vModelViewMatrix));\n    vViewSpacePosition = vec3(vModelViewMatrix * vec4(aPosition, 1.));\n\tvViewSpaceNormal = normalize(vec3(vNormalMatrix * vec4(aNormal, 0.)));\n\tvTexCoords = aTexCoords;\n    vFragPos = vec3(uModelMatrix * vec4(aPosition, 1.0));\n    vFragPosLightSpace = uLightSpaceMatrix * vec4(vFragPos, 1.0);\n    gl_Position =  vModelViewProjMatrix * vec4(aPosition, 1.);\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/shaders/shadowMapShader.vs.glsl b/src/shaders/shadowMapShader.vs.glsl
--- a/src/shaders/shadowMapShader.vs.glsl	(revision 9f0c7e7233dd62ecbf242a34fa8658ed057f1b53)
+++ b/src/shaders/shadowMapShader.vs.glsl	(date 1679786864936)
@@ -3,12 +3,14 @@
 layout(location = 0) in vec3 aPosition;
 layout(location = 1) in vec3 aNormal;
 layout(location = 2) in vec2 aTexCoords;
+layout(location = 3) in vec3 aTangents;
 
 out vec3 vViewSpacePosition;
 out vec3 vViewSpaceNormal;
 out vec2 vTexCoords;
 out vec4 vFragPosLightSpace;
 out vec3 vFragPos;
+out mat3 vTBN;
 
 uniform mat4 uViewMatrix;
 uniform mat4 uModelMatrix;
@@ -25,5 +27,15 @@
 	vTexCoords = aTexCoords;
     vFragPos = vec3(uModelMatrix * vec4(aPosition, 1.0));
     vFragPosLightSpace = uLightSpaceMatrix * vec4(vFragPos, 1.0);
+
+    vec3 T = normalize(vec3(vModelViewMatrix * vec4(aTangents, 0.0)));
+    vec3 N = vViewSpaceNormal;
+
+    T = normalize(T - dot(T, N) * N);
+    // compute bitangent from cross product
+    vec3 B = cross(N, T);
+
+    vTBN = mat3(T, B, N);
+
     gl_Position =  vModelViewProjMatrix * vec4(aPosition, 1.);
 }
\ No newline at end of file
Index: src/Data.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by lebonq on 12/01/23.\n//\n\n#ifndef GLTF_VIEWER_DATA_HPP\n#define GLTF_VIEWER_DATA_HPP\n\n#include \"glad/glad.h\"\n\nconst GLuint VERTEX_ATTRIB_POSITION_IDX = 0;\nconst GLuint VERTEX_ATTRIB_NORMAL_IDX = 1;\nconst GLuint VERTEX_ATTRIB_TEXCOORD0_IDX = 2;\n\n#endif // GLTF_VIEWER_DATA_HPP\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Data.hpp b/src/Data.hpp
--- a/src/Data.hpp	(revision 9f0c7e7233dd62ecbf242a34fa8658ed057f1b53)
+++ b/src/Data.hpp	(date 1679784455008)
@@ -10,5 +10,6 @@
 const GLuint VERTEX_ATTRIB_POSITION_IDX = 0;
 const GLuint VERTEX_ATTRIB_NORMAL_IDX = 1;
 const GLuint VERTEX_ATTRIB_TEXCOORD0_IDX = 2;
+const GLuint VERTEX_ATTRIB_TANGEANT_IDX = 3;
 
 #endif // GLTF_VIEWER_DATA_HPP
Index: src/shaders/pbr_directional_light_shadows.fs.glsl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#version 330 core\n\n// A reference implementation can be found here:\n// https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/master/src/shaders/metallic-roughness.frag\n// Here we implement a simpler version handling only one directional light and\n// no normal map/opacity map\n\nin vec3 vViewSpacePosition;\nin vec3 vViewSpaceNormal;\nin vec2 vTexCoords;\nin vec4 vFragPosLightSpace;\nin vec3 vFragPos;\n\n// Here we use vTexCoords but we should use vTexCoords1 or vTexCoords2 depending\n// on the material because glTF can handle two texture coordinates sets per\n// object see\n// https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/master/src/shaders/textures.glsl\n// for a reference implementation\n\nuniform vec3 uLightDirection;\nuniform vec3 uLightIntensity;\n\nuniform vec4 uBaseColorFactor;\nuniform float uMetallicFactor;\nuniform float uRoughnessFactor;\nuniform vec3 uEmissiveFactor;\nuniform float uOcclusionStrength;\n\nuniform sampler2D uBaseColorTexture;\nuniform sampler2D uMetallicRoughnessTexture;\nuniform sampler2D uEmissiveTexture;\nuniform sampler2D uOcclusionTexture;\n\nuniform sampler2D uDirLightShadowMap;\n\nuniform int uApplyOcclusion;\n\nout vec3 fColor;\n\n// Constants\nconst float GAMMA = 2.2;\nconst float INV_GAMMA = 1. / GAMMA;\nconst float M_PI = 3.141592653589793;\nconst float M_1_PI = 1.0 / M_PI;\n\n// We need some simple tone mapping functions\n// Basic gamma = 2.2 implementation\n// Stolen here:\n// https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/master/src/shaders/tonemapping.glsl\n\n// linear to sRGB approximation\n// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\nvec3 LINEARtoSRGB(vec3 color) { return pow(color, vec3(INV_GAMMA)); }\n\n// sRGB to linear approximation\n// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n  return vec4(pow(srgbIn.xyz, vec3(GAMMA)), srgbIn.w);\n}\n\n// The model is mathematically described here\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-b-brdf-implementation\n// We try to use the same or similar names for variables\n// One thing that is not descibed in the documentation is that the BRDF value\n// \"f\" must be multiplied by NdotL at the end.\nvoid main()\n{\n  vec3 N = normalize(vViewSpaceNormal);\n  vec3 V = normalize(-vViewSpacePosition);\n  vec3 L = uLightDirection;\n  vec3 H = normalize(L + V);\n\n  vec4 baseColorFromTexture =\n      SRGBtoLINEAR(texture(uBaseColorTexture, vTexCoords));\n  vec4 metallicRougnessFromTexture =\n      texture(uMetallicRoughnessTexture, vTexCoords);\n\n  vec4 baseColor = uBaseColorFactor * baseColorFromTexture;\n  vec3 metallic = vec3(uMetallicFactor * metallicRougnessFromTexture.b);\n  float roughness = uRoughnessFactor * metallicRougnessFromTexture.g;\n\n  // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#pbrmetallicroughnessmetallicroughnesstexture\n  // \"The metallic-roughness texture.The metalness values are sampled from the B\n  // channel.The roughness values are sampled from the G channel.\"\n\n  vec3 dielectricSpecular = vec3(0.04);\n  vec3 black = vec3(0.);\n\n  vec3 c_diff =\n      mix(baseColor.rgb * (1. - dielectricSpecular.r), black, metallic);\n  vec3 F_0 = mix(vec3(dielectricSpecular), baseColor.rgb, metallic);\n  float alpha = roughness * roughness;\n\n  float VdotH = clamp(dot(V, H), 0., 1.);\n  float baseShlickFactor = 1. - VdotH;\n  float shlickFactor = baseShlickFactor * baseShlickFactor; // power 2\n  shlickFactor *= shlickFactor;                             // power 4\n  shlickFactor *= baseShlickFactor;                         // power 5\n  vec3 F = F_0 + (vec3(1.) - F_0) * shlickFactor;\n\n  float sqrAlpha = alpha * alpha;\n  float NdotL = clamp(dot(N, L), 0., 1.);\n  float NdotV = clamp(dot(N, V), 0., 1.);\n  float visDenominator =\n      NdotL * sqrt(NdotV * NdotV * (1. - sqrAlpha) + sqrAlpha) +\n      NdotV * sqrt(NdotL * NdotL * (1. - sqrAlpha) + sqrAlpha);\n  float Vis = visDenominator > 0. ? 0.5 / visDenominator : 0.0;\n\n  float NdotH = clamp(dot(N, H), 0., 1.);\n  float baseDenomD = (NdotH * NdotH * (sqrAlpha - 1.) + 1.);\n  float D = M_1_PI * sqrAlpha / (baseDenomD * baseDenomD);\n\n  vec3 f_specular = F * Vis * D;\n\n  vec3 diffuse = c_diff * M_1_PI;\n\n  vec3 f_diffuse = (1. - F) * diffuse;\n  vec3 emissive = SRGBtoLINEAR(texture2D(uEmissiveTexture, vTexCoords)).rgb *\n                  uEmissiveFactor;\n\n  float shadow = 0.0f;\n  vec3 lightCoords = vFragPosLightSpace.xyz / vFragPosLightSpace.w;\n  if(lightCoords.z <= 1.0f){\n    lightCoords = (lightCoords + 1.0f) / 2.0f;\n\n    float bias = 0.005f;\n    float currentDepth = lightCoords.z;\n\n    // Smoothens out the shadows\n    int radius = 2;\n    vec2 pixelSize = 1.0 / textureSize(uDirLightShadowMap, 0);\n    for(int y = -radius; y <= radius; y++)\n    {\n      for(int x = -radius; x <= radius; x++)\n      {\n        float closestDepth = texture(uDirLightShadowMap, lightCoords.xy + vec2(x, y) * pixelSize).r;\n        if (currentDepth > closestDepth + bias)\n        shadow += 0.79f;\n      }\n    }\n    // Get average shadow\n    shadow /= pow((radius * 2 + 1), 2);\n  }\n\n  vec3 color = (f_diffuse *(1.0f-shadow) + f_specular *(1.0f-shadow)) * uLightIntensity * NdotL;\n  color *= (1.0f-shadow);\n  color += emissive;\n\n  if (1 == uApplyOcclusion) {\n    float ao = texture2D(uOcclusionTexture, vTexCoords).r;\n    color = mix(color, color * ao, uOcclusionStrength);\n  }\n\n  fColor = LINEARtoSRGB(color);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/shaders/pbr_directional_light_shadows.fs.glsl b/src/shaders/pbr_directional_light_shadows.fs.glsl
--- a/src/shaders/pbr_directional_light_shadows.fs.glsl	(revision 9f0c7e7233dd62ecbf242a34fa8658ed057f1b53)
+++ b/src/shaders/pbr_directional_light_shadows.fs.glsl	(date 1679786440290)
@@ -10,6 +10,7 @@
 in vec2 vTexCoords;
 in vec4 vFragPosLightSpace;
 in vec3 vFragPos;
+in mat3 vTBN;
 
 // Here we use vTexCoords but we should use vTexCoords1 or vTexCoords2 depending
 // on the material because glTF can handle two texture coordinates sets per
@@ -25,11 +26,13 @@
 uniform float uRoughnessFactor;
 uniform vec3 uEmissiveFactor;
 uniform float uOcclusionStrength;
+uniform float uNormalScale;
 
 uniform sampler2D uBaseColorTexture;
 uniform sampler2D uMetallicRoughnessTexture;
 uniform sampler2D uEmissiveTexture;
 uniform sampler2D uOcclusionTexture;
+uniform sampler2D uNormalTexture;
 
 uniform sampler2D uDirLightShadowMap;
 
@@ -66,7 +69,9 @@
 // "f" must be multiplied by NdotL at the end.
 void main()
 {
-  vec3 N = normalize(vViewSpaceNormal);
+  //vec3 N = normalize(vViewSpaceNormal);
+  vec3 N = texture(uNormalTexture, vTexCoords).rgb;
+  N = vTBN * normalize((N * 2.0 - 1.0)* vec3(uNormalScale, uNormalScale, 1.0f));
   vec3 V = normalize(-vViewSpacePosition);
   vec3 L = uLightDirection;
   vec3 H = normalize(L + V);
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"CMakePresetLoader\">{\n  &quot;useNewFormat&quot;: true\n}</component>\n  <component name=\"CMakeReloadState\">\n    <option name=\"reloaded\" value=\"true\" />\n  </component>\n  <component name=\"CMakeRunConfigurationManager\">\n    <generated>\n      <config projectName=\"gltf-viewer\" targetName=\"uninstall\" />\n      <config projectName=\"gltf-viewer\" targetName=\"glfw\" />\n      <config projectName=\"gltf-viewer\" targetName=\"gltf-viewer\" />\n    </generated>\n  </component>\n  <component name=\"CMakeSettings\">\n    <configurations>\n      <configuration PROFILE_NAME=\"Debug\" ENABLED=\"true\" CONFIG_NAME=\"Debug\" />\n      <configuration PROFILE_NAME=\"Release\" ENABLED=\"true\" CONFIG_NAME=\"Release\" />\n    </configurations>\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"19de7924-f124-4159-82f0-f1cbf3d8c564\" name=\"Changes\" comment=\"Fine tune shadow mapping\" />\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"ExecutionTargetManager\" SELECTED_TARGET=\"CMakeBuildProfile:Debug\" />\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"shader-template\" />\n        <option value=\"GLSL Shader\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"tutorial-v1\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"MarkdownSettingsMigration\">\n    <option name=\"stateVersion\" value=\"1\" />\n  </component>\n  <component name=\"ProblemsViewState\">\n    <option name=\"selectedTabId\" value=\"ProjectErrors\" />\n  </component>\n  <component name=\"ProjectId\" id=\"2Ju0ZFxdb0g28YK4O1wHkVJNW6o\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">{\n  &quot;keyToString&quot;: {\n    &quot;Git.Branch.Popup.ShowAllRemotes&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.cidr.known.project.marker&quot;: &quot;true&quot;,\n    &quot;ToolWindowDebug.ShowToolbar&quot;: &quot;false&quot;,\n    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,\n    &quot;cf.advertisement.text.overridden&quot;: &quot;true&quot;,\n    &quot;cf.first.check.clang-format&quot;: &quot;false&quot;,\n    &quot;cidr.known.project.marker&quot;: &quot;true&quot;,\n    &quot;last_opened_file_path&quot;: &quot;/home/lebonq/Documents/M2-Image/Geometrie-Projective/projet/project_4D_fractal&quot;,\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\n    &quot;run.code.analysis.last.selected.profile&quot;: &quot;pProject Default&quot;,\n    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.lookFeel&quot;,\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\n  }\n}</component>\n  <component name=\"RecentsManager\">\n    <key name=\"CopyFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/src/shaders\" />\n    </key>\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/src\" />\n    </key>\n  </component>\n  <component name=\"RunManager\" selected=\"CMake Application.View Sponza\">\n    <configuration name=\"Render Helmet\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" PROGRAM_PARAMS=\"viewer ../../gltf-sample-models/2.0/DamagedHelmet/glTF/DamagedHelmet.gltf --lookat 0,0,2.29362,0,-0.0898785,1.29767,0,0.995953,-0.0898785 --output helmet.png --w 3000 --h 2000\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"gltf-viewer\" TARGET_NAME=\"gltf-viewer\" CONFIG_NAME=\"Debug\" RUN_TARGET_PROJECT_NAME=\"gltf-viewer\" RUN_TARGET_NAME=\"gltf-viewer\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"Render Sponza\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" PROGRAM_PARAMS=\"viewer ../../gltf-sample-models/2.0/Sponza/glTF/Sponza.gltf --lookat 0.926627,4.73407,0.16938,-0.0712768,4.70099,0.113776,-0.0330304,0.999454,-0.00183996 --output sponza.png --w 3000 --h 2000\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"gltf-viewer\" TARGET_NAME=\"gltf-viewer\" CONFIG_NAME=\"Debug\" RUN_TARGET_PROJECT_NAME=\"gltf-viewer\" RUN_TARGET_NAME=\"gltf-viewer\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"View Helmet\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" PROGRAM_PARAMS=\"viewer ../../gltf-sample-models/2.0/DamagedHelmet/glTF/DamagedHelmet.gltf --lookat 0,0,2.29362,0,-0.0898785,1.29767,0,0.995953,-0.0898785\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"gltf-viewer\" TARGET_NAME=\"gltf-viewer\" CONFIG_NAME=\"Debug\" RUN_TARGET_PROJECT_NAME=\"gltf-viewer\" RUN_TARGET_NAME=\"gltf-viewer\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"View Sponza\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" PROGRAM_PARAMS=\"viewer ../../gltf-sample-models/2.0/Sponza/glTF/Sponza.gltf --lookat 0.926627,4.73407,0.16938,-0.0712768,4.70099,0.113776,-0.0330304,0.999454,-0.00183996\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"gltf-viewer\" TARGET_NAME=\"gltf-viewer\" CONFIG_NAME=\"Debug\" RUN_TARGET_PROJECT_NAME=\"gltf-viewer\" RUN_TARGET_NAME=\"gltf-viewer\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"glfw\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"gltf-viewer\" TARGET_NAME=\"glfw\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"uninstall\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"gltf-viewer\" TARGET_NAME=\"uninstall\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <list>\n      <item itemvalue=\"CMake Application.Render Helmet\" />\n      <item itemvalue=\"CMake Application.Render Sponza\" />\n      <item itemvalue=\"CMake Application.View Helmet\" />\n      <item itemvalue=\"CMake Application.View Sponza\" />\n      <item itemvalue=\"CMake Application.uninstall\" />\n      <item itemvalue=\"CMake Application.glfw\" />\n    </list>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"19de7924-f124-4159-82f0-f1cbf3d8c564\" name=\"Changes\" comment=\"\" />\n      <created>1672912370309</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1672912370309</updated>\n      <workItem from=\"1672912377364\" duration=\"328000\" />\n      <workItem from=\"1672912724076\" duration=\"4692000\" />\n      <workItem from=\"1672945705746\" duration=\"80000\" />\n      <workItem from=\"1673008798570\" duration=\"152000\" />\n      <workItem from=\"1673270034062\" duration=\"633000\" />\n      <workItem from=\"1673272926801\" duration=\"993000\" />\n      <workItem from=\"1673510133776\" duration=\"3272000\" />\n      <workItem from=\"1673515738364\" duration=\"5872000\" />\n      <workItem from=\"1673962551507\" duration=\"917000\" />\n      <workItem from=\"1674481564520\" duration=\"22000\" />\n      <workItem from=\"1674493317732\" duration=\"43000\" />\n      <workItem from=\"1674652470567\" duration=\"11110000\" />\n      <workItem from=\"1678354602427\" duration=\"1558000\" />\n      <workItem from=\"1678357472893\" duration=\"3303000\" />\n      <workItem from=\"1678577736337\" duration=\"5000\" />\n      <workItem from=\"1678812181914\" duration=\"2441000\" />\n      <workItem from=\"1678814654414\" duration=\"12000\" />\n      <workItem from=\"1678814819428\" duration=\"134000\" />\n      <workItem from=\"1678814967341\" duration=\"913000\" />\n      <workItem from=\"1678871961168\" duration=\"5028000\" />\n      <workItem from=\"1678885133478\" duration=\"6853000\" />\n      <workItem from=\"1679047857528\" duration=\"3608000\" />\n      <workItem from=\"1679055137821\" duration=\"48000\" />\n      <workItem from=\"1679055607939\" duration=\"1103000\" />\n      <workItem from=\"1679056778737\" duration=\"13469000\" />\n      <workItem from=\"1679082666066\" duration=\"5000\" />\n      <workItem from=\"1679082920380\" duration=\"11535000\" />\n      <workItem from=\"1679135539588\" duration=\"8040000\" />\n      <workItem from=\"1679154340928\" duration=\"4645000\" />\n      <workItem from=\"1679263035794\" duration=\"780000\" />\n      <workItem from=\"1679345522178\" duration=\"186000\" />\n      <workItem from=\"1679391159930\" duration=\"9064000\" />\n      <workItem from=\"1679434074582\" duration=\"2792000\" />\n      <workItem from=\"1679436875596\" duration=\"10000\" />\n      <workItem from=\"1679602346933\" duration=\"51000\" />\n      <workItem from=\"1679694660761\" duration=\"19000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"Add loadGltf and createBufferObjects\">\n      <created>1673517456196</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1673517456196</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"Add creation of vertexArrayObjects\">\n      <created>1674656648512</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1674656648512</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"Add Draw Function\">\n      <created>1674661629342</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1674661629342</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"Add trackball\">\n      <created>1678360630832</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1678360630832</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"Add trackball\">\n      <created>1678360654766</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1678360654766</updated>\n    </task>\n    <task id=\"LOCAL-00006\" summary=\"Add trackball and new camera controller\">\n      <created>1678815121902</created>\n      <option name=\"number\" value=\"00006\" />\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1678815121902</updated>\n    </task>\n    <task id=\"LOCAL-00007\" summary=\"Add directionnal light\">\n      <created>1678885369498</created>\n      <option name=\"number\" value=\"00007\" />\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1678885369498</updated>\n    </task>\n    <task id=\"LOCAL-00008\" summary=\"Push\">\n      <created>1679040074764</created>\n      <option name=\"number\" value=\"00008\" />\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1679040074764</updated>\n    </task>\n    <task id=\"LOCAL-00009\" summary=\"First try of shadow mapping\">\n      <created>1679067948988</created>\n      <option name=\"number\" value=\"00009\" />\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1679067948988</updated>\n    </task>\n    <task id=\"LOCAL-00010\" summary=\"Some bug fix\">\n      <created>1679134682606</created>\n      <option name=\"number\" value=\"00010\" />\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1679134682606</updated>\n    </task>\n    <task id=\"LOCAL-00011\" summary=\"Working Shadow Map\">\n      <created>1679157479252</created>\n      <option name=\"number\" value=\"00011\" />\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1679157479252</updated>\n    </task>\n    <task id=\"LOCAL-00012\" summary=\"Working Shadow Map\">\n      <created>1679159528562</created>\n      <option name=\"number\" value=\"00012\" />\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1679159528562</updated>\n    </task>\n    <task id=\"LOCAL-00013\" summary=\"Fine tune shadow mapping\">\n      <created>1679436613670</created>\n      <option name=\"number\" value=\"00013\" />\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1679436613670</updated>\n    </task>\n    <task id=\"LOCAL-00014\" summary=\"Fine tune shadow mapping\">\n      <created>1679436721139</created>\n      <option name=\"number\" value=\"00014\" />\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1679436721139</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"15\" />\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"Add loadGltf and createBufferObjects\" />\n    <MESSAGE value=\"Add creation of vertexArrayObjects\" />\n    <MESSAGE value=\"Add Draw Function\" />\n    <MESSAGE value=\"Add trackball\" />\n    <MESSAGE value=\"Add trackball and new camera controller\" />\n    <MESSAGE value=\"Add directionnal light\" />\n    <MESSAGE value=\"Push\" />\n    <MESSAGE value=\"First try of shadow mapping\" />\n    <MESSAGE value=\"Some bug fix\" />\n    <MESSAGE value=\"Working Shadow Map\" />\n    <MESSAGE value=\"Fine tune shadow mapping\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Fine tune shadow mapping\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 9f0c7e7233dd62ecbf242a34fa8658ed057f1b53)
+++ b/.idea/workspace.xml	(date 1679788926195)
@@ -23,13 +23,20 @@
     </configurations>
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="19de7924-f124-4159-82f0-f1cbf3d8c564" name="Changes" comment="Fine tune shadow mapping" />
+    <list default="true" id="19de7924-f124-4159-82f0-f1cbf3d8c564" name="Changes" comment="Update shaders">
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/Data.hpp" beforeDir="false" afterPath="$PROJECT_DIR$/src/Data.hpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/ViewerApplication.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/src/ViewerApplication.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/shaders/pbr_directional_light_shadows.fs.glsl" beforeDir="false" afterPath="$PROJECT_DIR$/src/shaders/pbr_directional_light_shadows.fs.glsl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/shaders/shadowMapShader.vs.glsl" beforeDir="false" afterPath="$PROJECT_DIR$/src/shaders/shadowMapShader.vs.glsl" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/utils/shaders.hpp" beforeDir="false" afterPath="$PROJECT_DIR$/src/utils/shaders.hpp" afterDir="false" />
+    </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
     <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
     <option name="LAST_RESOLUTION" value="IGNORE" />
   </component>
-  <component name="ExecutionTargetManager" SELECTED_TARGET="CMakeBuildProfile:Debug" />
+  <component name="ExecutionTargetManager" SELECTED_TARGET="CMakeBuildProfile:Release" />
   <component name="FileTemplateManagerImpl">
     <option name="RECENT_TEMPLATES">
       <list>
@@ -41,7 +48,7 @@
   <component name="Git.Settings">
     <option name="RECENT_BRANCH_BY_REPOSITORY">
       <map>
-        <entry key="$PROJECT_DIR$" value="tutorial-v1" />
+        <entry key="$PROJECT_DIR$" value="normal-mapping" />
       </map>
     </option>
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
@@ -107,11 +114,6 @@
         <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
       </method>
     </configuration>
-    <configuration default="true" type="CMakeRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" ELEVATE="false" USE_EXTERNAL_CONSOLE="false" PASS_PARENT_ENVS_2="true">
-      <method v="2">
-        <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
-      </method>
-    </configuration>
     <configuration name="glfw" type="CMakeRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" ELEVATE="false" USE_EXTERNAL_CONSOLE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="gltf-viewer" TARGET_NAME="glfw" CONFIG_NAME="Debug">
       <method v="2">
         <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
@@ -175,6 +177,7 @@
       <workItem from="1679436875596" duration="10000" />
       <workItem from="1679602346933" duration="51000" />
       <workItem from="1679694660761" duration="19000" />
+      <workItem from="1679787930117" duration="969000" />
     </task>
     <task id="LOCAL-00001" summary="Add loadGltf and createBufferObjects">
       <created>1673517456196</created>
@@ -274,7 +277,14 @@
       <option name="project" value="LOCAL" />
       <updated>1679436721139</updated>
     </task>
-    <option name="localTasksCounter" value="15" />
+    <task id="LOCAL-00015" summary="Update shaders">
+      <created>1679783878488</created>
+      <option name="number" value="00015" />
+      <option name="presentableId" value="LOCAL-00015" />
+      <option name="project" value="LOCAL" />
+      <updated>1679783878488</updated>
+    </task>
+    <option name="localTasksCounter" value="16" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -303,6 +313,7 @@
     <MESSAGE value="Some bug fix" />
     <MESSAGE value="Working Shadow Map" />
     <MESSAGE value="Fine tune shadow mapping" />
-    <option name="LAST_COMMIT_MESSAGE" value="Fine tune shadow mapping" />
+    <MESSAGE value="Update shaders" />
+    <option name="LAST_COMMIT_MESSAGE" value="Update shaders" />
   </component>
 </project>
\ No newline at end of file
Index: src/utils/shaders.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#pragma once\n\n#include \"filesystem.hpp\"\n#include <fstream>\n#include <glad/glad.h>\n#include <iostream>\n#include <memory>\n#include <sstream>\n#include <stdexcept>\n#include <string>\n#include <unordered_map>\n\nclass GLShader\n{\n  GLuint m_GLId;\n  typedef std::unique_ptr<char[]> CharBuffer;\n\npublic:\n  GLShader(GLenum type) : m_GLId(glCreateShader(type)) {}\n\n  ~GLShader() { glDeleteShader(m_GLId); }\n\n  GLShader(const GLShader &) = delete;\n\n  GLShader &operator=(const GLShader &) = delete;\n\n  GLShader(GLShader &&rvalue) : m_GLId(rvalue.m_GLId) { rvalue.m_GLId = 0; }\n\n  GLShader &operator=(GLShader &&rvalue)\n  {\n    this->~GLShader();\n    m_GLId = rvalue.m_GLId;\n    rvalue.m_GLId = 0;\n    return *this;\n  }\n\n  GLuint glId() const { return m_GLId; }\n\n  void setSource(const GLchar *src) { glShaderSource(m_GLId, 1, &src, 0); }\n\n  void setSource(const std::string &src) { setSource(src.c_str()); }\n\n  bool compile()\n  {\n    glCompileShader(m_GLId);\n    return getCompileStatus();\n  }\n\n  bool getCompileStatus() const\n  {\n    GLint status;\n    glGetShaderiv(m_GLId, GL_COMPILE_STATUS, &status);\n    return status == GL_TRUE;\n  }\n\n  std::string getInfoLog() const\n  {\n    GLint logLength;\n    glGetShaderiv(m_GLId, GL_INFO_LOG_LENGTH, &logLength);\n\n    CharBuffer buffer(new char[logLength]);\n    glGetShaderInfoLog(m_GLId, logLength, 0, buffer.get());\n\n    return std::string(buffer.get());\n  }\n};\n\ninline std::string loadShaderSource(const fs::path &filepath)\n{\n  std::ifstream input(filepath.string());\n  if (!input) {\n    std::stringstream ss;\n    ss << \"Unable to open file \" << filepath;\n    throw std::runtime_error(ss.str());\n  }\n\n  std::stringstream buffer;\n  buffer << input.rdbuf();\n\n  return buffer.str();\n}\n\ntemplate <typename StringType>\nGLShader compileShader(GLenum type, StringType &&src)\n{\n  GLShader shader(type);\n  shader.setSource(std::forward<StringType>(src));\n  if (!shader.compile()) {\n    std::cerr << shader.getInfoLog() << std::endl;\n    throw std::runtime_error(shader.getInfoLog());\n  }\n  return shader;\n}\n\n// Load and compile a shader according to the following naming convention:\n// *.vs.glsl -> vertex shader\n// *.fs.glsl -> fragment shader\n// *.gs.glsl -> geometry shader\n// *.cs.glsl -> compute shader\ninline GLShader loadShader(const fs::path &shaderPath)\n{\n  static auto extToShaderType =\n      std::unordered_map<std::string, std::pair<GLenum, std::string>>(\n          {{\".vs\", {GL_VERTEX_SHADER, \"vertex\"}},\n              {\".fs\", {GL_FRAGMENT_SHADER, \"fragment\"}},\n              {\".gs\", {GL_GEOMETRY_SHADER, \"geometry\"}},\n              {\".cs\", {GL_COMPUTE_SHADER, \"compute\"}}});\n\n  const auto ext = shaderPath.stem().extension();\n  const auto it = extToShaderType.find(ext.string());\n  if (it == end(extToShaderType)) {\n    std::cerr << \"Unrecognized shader extension \" << ext << std::endl;\n    throw std::runtime_error(\"Unrecognized shader extension \" + ext.string());\n  }\n\n  std::clog << \"Compiling \" << (*it).second.second << \" shader \" << shaderPath\n            << \"\\n\";\n\n  GLShader shader{(*it).second.first};\n  shader.setSource(loadShaderSource(shaderPath));\n  shader.compile();\n  if (!shader.getCompileStatus()) {\n    std::cerr << \"Shader compilation error:\" << shader.getInfoLog()\n              << std::endl;\n    throw std::runtime_error(\"Shader compilation error:\" + shader.getInfoLog());\n  }\n  return shader;\n}\n\nclass GLProgram\n{\n  GLuint m_GLId;\n  typedef std::unique_ptr<char[]> CharBuffer;\npublic:\n  GLint m_uViewMatrixLocation;\n  GLint m_uProjectionMatrixLocation;\n  GLint m_uModelMatrixLocation;\n  GLint m_ulightDirection;\n  GLint m_ulightIntensity;\n  GLint m_uBaseColorTexture;\n  GLint m_uBaseColorFactor;\n  GLint m_uMetallicRoughnessTexture;\n  GLint m_uMetallicFactor;\n  GLint m_uRoughnessFactor;\n  GLint m_uEmissiveTexture;\n  GLint m_uEmissiveFactor;\n  GLint m_uOcclusionTexture;\n  GLint m_uOcclusionStrength;\n  GLint m_uApplyOcclusion;\n  GLint m_uLightSpaceMatrix;\n  GLint m_uDirLightShadowMap;\n\n  GLProgram() : m_GLId(glCreateProgram()) { }\n\n  ~GLProgram() { glDeleteProgram(m_GLId); }\n\n  GLProgram(const GLProgram &) = delete;\n\n  GLProgram &operator=(const GLProgram &) = delete;\n\n  GLProgram(GLProgram &&rvalue) : m_GLId(rvalue.m_GLId) { rvalue.m_GLId = 0; }\n\n  GLProgram &operator=(GLProgram &&rvalue)\n  {\n    this->~GLProgram();\n    m_GLId = rvalue.m_GLId;\n    rvalue.m_GLId = 0;\n    return *this;\n  }\n\n  GLuint glId() const { return m_GLId; }\n\n  void attachShader(const GLShader &shader)\n  {\n    glAttachShader(m_GLId, shader.glId());\n  }\n\n  bool link()\n  {\n    glLinkProgram(m_GLId);\n    return getLinkStatus();\n  }\n\n  bool getLinkStatus() const\n  {\n    GLint linkStatus;\n    glGetProgramiv(m_GLId, GL_LINK_STATUS, &linkStatus);\n    return linkStatus == GL_TRUE;\n  }\n\n  std::string getInfoLog() const\n  {\n    GLint logLength;\n    glGetProgramiv(m_GLId, GL_INFO_LOG_LENGTH, &logLength);\n\n    CharBuffer buffer(new char[logLength]);\n    glGetProgramInfoLog(m_GLId, logLength, 0, buffer.get());\n\n    return std::string(buffer.get());\n  }\n\n  void use() const { glUseProgram(m_GLId); }\n\n  GLint getUniformLocation(const GLchar *name) const\n  {\n    GLint location = glGetUniformLocation(m_GLId, name);\n    return location;\n  }\n\n  void setUniform()\n  {\n    m_uViewMatrixLocation = getUniformLocation(\"uViewMatrix\");\n    m_uProjectionMatrixLocation =\n        getUniformLocation(\"uProjectionMatrix\");\n    m_uModelMatrixLocation = getUniformLocation(\"uModelMatrix\");\n    m_ulightDirection = getUniformLocation(\"uLightDirection\");\n    m_ulightIntensity = getUniformLocation(\"uLightIntensity\");\n    m_uBaseColorTexture = getUniformLocation(\"uBaseColorTexture\");\n    m_uBaseColorFactor = getUniformLocation(\"uBaseColorFactor\");\n    m_uMetallicRoughnessTexture =\n        getUniformLocation(\"uMetallicRoughnessTexture\");\n    m_uMetallicFactor = getUniformLocation(\"uMetallicFactor\");\n    m_uRoughnessFactor = getUniformLocation(\"uRoughnessFactor\");\n    m_uEmissiveTexture = getUniformLocation(\"uEmissiveTexture\");\n    m_uEmissiveFactor = getUniformLocation(\"uEmissiveFactor\");\n    m_uOcclusionTexture = getUniformLocation(\"uOcclusionTexture\");\n    m_uOcclusionStrength = getUniformLocation(\"uOcclusionStrength\");\n    m_uApplyOcclusion = getUniformLocation(\"uApplyOcclusion\");\n    m_uLightSpaceMatrix = getUniformLocation(\"uLightSpaceMatrix\");\n    m_uDirLightShadowMap = getUniformLocation(\"uDirLightShadowMap\");\n  }\n\n  GLint getAttribLocation(const GLchar *name) const\n  {\n    GLint location = glGetAttribLocation(m_GLId, name);\n    return location;\n  }\n\n  void bindAttribLocation(GLuint index, const GLchar *name) const\n  {\n    glBindAttribLocation(m_GLId, index, name);\n  }\n\n};\n\ninline GLProgram buildProgram(std::initializer_list<GLShader> shaders)\n{\n  GLProgram program;\n  for (const auto &shader : shaders) {\n    program.attachShader(shader);\n  }\n\n  if (!program.link()) {\n    std::cerr << program.getInfoLog() << std::endl;\n    throw std::runtime_error(program.getInfoLog());\n  }\n\n  return program;\n}\n\ntemplate <typename VSrc, typename FSrc>\nGLProgram buildProgram(VSrc &&vsrc, FSrc &&fsrc)\n{\n  GLShader vs = compileShader(GL_VERTEX_SHADER, std::forward<VSrc>(vsrc));\n  GLShader fs = compileShader(GL_FRAGMENT_SHADER, std::forward<FSrc>(fsrc));\n\n  return buildProgram({std::move(vs), std::move(fs)});\n}\n\ntemplate <typename VSrc, typename GSrc, typename FSrc>\nGLProgram buildProgram(VSrc &&vsrc, GSrc &&gsrc, FSrc &&fsrc)\n{\n  GLShader vs = compileShader(GL_VERTEX_SHADER, std::forward<VSrc>(vsrc));\n  GLShader gs = compileShader(GL_GEOMETRY_SHADER, std::forward<GSrc>(gsrc));\n  GLShader fs = compileShader(GL_FRAGMENT_SHADER, std::forward<FSrc>(fsrc));\n\n  return buildProgram({std::move(vs), std::move(gs), std::move(fs)});\n}\n\ntemplate <typename CSrc> GLProgram buildComputeProgram(CSrc &&src)\n{\n  GLShader cs = compileShader(GL_COMPUTE_SHADER, std::forward<CSrc>(src));\n  return buildProgram({std::move(cs)});\n  ;\n}\n\ninline GLProgram compileProgram(std::vector<fs::path> shaderPaths)\n{\n  GLProgram program;\n  for (const auto &path : shaderPaths) {\n    auto shader = loadShader(path);\n    program.attachShader(shader);\n  }\n  program.link();\n  if (!program.getLinkStatus()) {\n    std::cerr << \"Program link error:\" << program.getInfoLog() << std::endl;\n    throw std::runtime_error(\"Program link error:\" + program.getInfoLog());\n  }\n\n  return program;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/utils/shaders.hpp b/src/utils/shaders.hpp
--- a/src/utils/shaders.hpp	(revision 9f0c7e7233dd62ecbf242a34fa8658ed057f1b53)
+++ b/src/utils/shaders.hpp	(date 1679786359145)
@@ -149,6 +149,8 @@
   GLint m_uApplyOcclusion;
   GLint m_uLightSpaceMatrix;
   GLint m_uDirLightShadowMap;
+  GLint m_uNormalTexture;
+  GLint m_uNormalScale;
 
   GLProgram() : m_GLId(glCreateProgram()) { }
 
@@ -228,6 +230,8 @@
     m_uApplyOcclusion = getUniformLocation("uApplyOcclusion");
     m_uLightSpaceMatrix = getUniformLocation("uLightSpaceMatrix");
     m_uDirLightShadowMap = getUniformLocation("uDirLightShadowMap");
+    m_uNormalTexture = getUniformLocation("uNormalTexture");
+    m_uNormalScale = getUniformLocation("uNormalScale");
   }
 
   GLint getAttribLocation(const GLchar *name) const
