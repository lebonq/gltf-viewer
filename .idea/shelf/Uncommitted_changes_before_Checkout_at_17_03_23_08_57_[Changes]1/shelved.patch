Index: src/utils/shaders.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#pragma once\n\n#include \"filesystem.hpp\"\n#include <fstream>\n#include <glad/glad.h>\n#include <iostream>\n#include <memory>\n#include <sstream>\n#include <stdexcept>\n#include <string>\n#include <unordered_map>\n\nclass GLShader\n{\n  GLuint m_GLId;\n  typedef std::unique_ptr<char[]> CharBuffer;\n\npublic:\n  GLShader(GLenum type) : m_GLId(glCreateShader(type)) {}\n\n  ~GLShader() { glDeleteShader(m_GLId); }\n\n  GLShader(const GLShader &) = delete;\n\n  GLShader &operator=(const GLShader &) = delete;\n\n  GLShader(GLShader &&rvalue) : m_GLId(rvalue.m_GLId) { rvalue.m_GLId = 0; }\n\n  GLShader &operator=(GLShader &&rvalue)\n  {\n    this->~GLShader();\n    m_GLId = rvalue.m_GLId;\n    rvalue.m_GLId = 0;\n    return *this;\n  }\n\n  GLuint glId() const { return m_GLId; }\n\n  void setSource(const GLchar *src) { glShaderSource(m_GLId, 1, &src, 0); }\n\n  void setSource(const std::string &src) { setSource(src.c_str()); }\n\n  bool compile()\n  {\n    glCompileShader(m_GLId);\n    return getCompileStatus();\n  }\n\n  bool getCompileStatus() const\n  {\n    GLint status;\n    glGetShaderiv(m_GLId, GL_COMPILE_STATUS, &status);\n    return status == GL_TRUE;\n  }\n\n  std::string getInfoLog() const\n  {\n    GLint logLength;\n    glGetShaderiv(m_GLId, GL_INFO_LOG_LENGTH, &logLength);\n\n    CharBuffer buffer(new char[logLength]);\n    glGetShaderInfoLog(m_GLId, logLength, 0, buffer.get());\n\n    return std::string(buffer.get());\n  }\n};\n\ninline std::string loadShaderSource(const fs::path &filepath)\n{\n  std::ifstream input(filepath.string());\n  if (!input) {\n    std::stringstream ss;\n    ss << \"Unable to open file \" << filepath;\n    throw std::runtime_error(ss.str());\n  }\n\n  std::stringstream buffer;\n  buffer << input.rdbuf();\n\n  return buffer.str();\n}\n\ntemplate <typename StringType>\nGLShader compileShader(GLenum type, StringType &&src)\n{\n  GLShader shader(type);\n  shader.setSource(std::forward<StringType>(src));\n  if (!shader.compile()) {\n    std::cerr << shader.getInfoLog() << std::endl;\n    throw std::runtime_error(shader.getInfoLog());\n  }\n  return shader;\n}\n\n// Load and compile a shader according to the following naming convention:\n// *.vs.glsl -> vertex shader\n// *.fs.glsl -> fragment shader\n// *.gs.glsl -> geometry shader\n// *.cs.glsl -> compute shader\ninline GLShader loadShader(const fs::path &shaderPath)\n{\n  static auto extToShaderType =\n      std::unordered_map<std::string, std::pair<GLenum, std::string>>(\n          {{\".vs\", {GL_VERTEX_SHADER, \"vertex\"}},\n              {\".fs\", {GL_FRAGMENT_SHADER, \"fragment\"}},\n              {\".gs\", {GL_GEOMETRY_SHADER, \"geometry\"}},\n              {\".cs\", {GL_COMPUTE_SHADER, \"compute\"}}});\n\n  const auto ext = shaderPath.stem().extension();\n  const auto it = extToShaderType.find(ext.string());\n  if (it == end(extToShaderType)) {\n    std::cerr << \"Unrecognized shader extension \" << ext << std::endl;\n    throw std::runtime_error(\"Unrecognized shader extension \" + ext.string());\n  }\n\n  std::clog << \"Compiling \" << (*it).second.second << \" shader \" << shaderPath\n            << \"\\n\";\n\n  GLShader shader{(*it).second.first};\n  shader.setSource(loadShaderSource(shaderPath));\n  shader.compile();\n  if (!shader.getCompileStatus()) {\n    std::cerr << \"Shader compilation error:\" << shader.getInfoLog()\n              << std::endl;\n    throw std::runtime_error(\"Shader compilation error:\" + shader.getInfoLog());\n  }\n  return shader;\n}\n\nclass GLProgram\n{\n  GLuint m_GLId;\n  typedef std::unique_ptr<char[]> CharBuffer;\n\npublic:\n  GLProgram() : m_GLId(glCreateProgram()) {}\n\n  ~GLProgram() { glDeleteProgram(m_GLId); }\n\n  GLProgram(const GLProgram &) = delete;\n\n  GLProgram &operator=(const GLProgram &) = delete;\n\n  GLProgram(GLProgram &&rvalue) : m_GLId(rvalue.m_GLId) { rvalue.m_GLId = 0; }\n\n  GLProgram &operator=(GLProgram &&rvalue)\n  {\n    this->~GLProgram();\n    m_GLId = rvalue.m_GLId;\n    rvalue.m_GLId = 0;\n    return *this;\n  }\n\n  GLuint glId() const { return m_GLId; }\n\n  void attachShader(const GLShader &shader)\n  {\n    glAttachShader(m_GLId, shader.glId());\n  }\n\n  bool link()\n  {\n    glLinkProgram(m_GLId);\n    return getLinkStatus();\n  }\n\n  bool getLinkStatus() const\n  {\n    GLint linkStatus;\n    glGetProgramiv(m_GLId, GL_LINK_STATUS, &linkStatus);\n    return linkStatus == GL_TRUE;\n  }\n\n  std::string getInfoLog() const\n  {\n    GLint logLength;\n    glGetProgramiv(m_GLId, GL_INFO_LOG_LENGTH, &logLength);\n\n    CharBuffer buffer(new char[logLength]);\n    glGetProgramInfoLog(m_GLId, logLength, 0, buffer.get());\n\n    return std::string(buffer.get());\n  }\n\n  void use() const { glUseProgram(m_GLId); }\n\n  GLint getUniformLocation(const GLchar *name) const\n  {\n    GLint location = glGetUniformLocation(m_GLId, name);\n    return location;\n  }\n\n  GLint getAttribLocation(const GLchar *name) const\n  {\n    GLint location = glGetAttribLocation(m_GLId, name);\n    return location;\n  }\n\n  void bindAttribLocation(GLuint index, const GLchar *name) const\n  {\n    glBindAttribLocation(m_GLId, index, name);\n  }\n};\n\ninline GLProgram buildProgram(std::initializer_list<GLShader> shaders)\n{\n  GLProgram program;\n  for (const auto &shader : shaders) {\n    program.attachShader(shader);\n  }\n\n  if (!program.link()) {\n    std::cerr << program.getInfoLog() << std::endl;\n    throw std::runtime_error(program.getInfoLog());\n  }\n\n  return program;\n}\n\ntemplate <typename VSrc, typename FSrc>\nGLProgram buildProgram(VSrc &&vsrc, FSrc &&fsrc)\n{\n  GLShader vs = compileShader(GL_VERTEX_SHADER, std::forward<VSrc>(vsrc));\n  GLShader fs = compileShader(GL_FRAGMENT_SHADER, std::forward<FSrc>(fsrc));\n\n  return buildProgram({std::move(vs), std::move(fs)});\n}\n\ntemplate <typename VSrc, typename GSrc, typename FSrc>\nGLProgram buildProgram(VSrc &&vsrc, GSrc &&gsrc, FSrc &&fsrc)\n{\n  GLShader vs = compileShader(GL_VERTEX_SHADER, std::forward<VSrc>(vsrc));\n  GLShader gs = compileShader(GL_GEOMETRY_SHADER, std::forward<GSrc>(gsrc));\n  GLShader fs = compileShader(GL_FRAGMENT_SHADER, std::forward<FSrc>(fsrc));\n\n  return buildProgram({std::move(vs), std::move(gs), std::move(fs)});\n}\n\ntemplate <typename CSrc> GLProgram buildComputeProgram(CSrc &&src)\n{\n  GLShader cs = compileShader(GL_COMPUTE_SHADER, std::forward<CSrc>(src));\n  return buildProgram({std::move(cs)});\n  ;\n}\n\ninline GLProgram compileProgram(std::vector<fs::path> shaderPaths)\n{\n  GLProgram program;\n  for (const auto &path : shaderPaths) {\n    auto shader = loadShader(path);\n    program.attachShader(shader);\n  }\n  program.link();\n  if (!program.getLinkStatus()) {\n    std::cerr << \"Program link error:\" << program.getInfoLog() << std::endl;\n    throw std::runtime_error(\"Program link error:\" + program.getInfoLog());\n  }\n  return program;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/utils/shaders.hpp b/src/utils/shaders.hpp
--- a/src/utils/shaders.hpp	
+++ b/src/utils/shaders.hpp	
@@ -200,6 +200,65 @@
   {
     glBindAttribLocation(m_GLId, index, name);
   }
+
+   // utility uniform functions
+    // ------------------------------------------------------------------------
+    void setBool(const std::string &name, bool value) const
+    {
+        glUniform1i(glGetUniformLocation(m_GLId, name.c_str()), (int)value);
+    }
+    // ------------------------------------------------------------------------
+    void setInt(const std::string &name, int value) const
+    {
+        glUniform1i(glGetUniformLocation(m_GLId, name.c_str()), value);
+    }
+    // ------------------------------------------------------------------------
+    void setFloat(const std::string &name, float value) const
+    {
+        glUniform1f(glGetUniformLocation(m_GLId, name.c_str()), value);
+    }
+    // ------------------------------------------------------------------------
+    void setVec2(const std::string &name, const glm::vec2 &value) const
+    {
+        glUniform2fv(glGetUniformLocation(m_GLId, name.c_str()), 1, &value[0]);
+    }
+    void setVec2(const std::string &name, float x, float y) const
+    {
+        glUniform2f(glGetUniformLocation(m_GLId, name.c_str()), x, y);
+    }
+    // ------------------------------------------------------------------------
+    void setVec3(const std::string &name, const glm::vec3 &value) const
+    {
+        glUniform3fv(glGetUniformLocation(m_GLId, name.c_str()), 1, &value[0]);
+    }
+    void setVec3(const std::string &name, float x, float y, float z) const
+    {
+        glUniform3f(glGetUniformLocation(m_GLId, name.c_str()), x, y, z);
+    }
+    // ------------------------------------------------------------------------
+    void setVec4(const std::string &name, const glm::vec4 &value) const
+    {
+        glUniform4fv(glGetUniformLocation(m_GLId, name.c_str()), 1, &value[0]);
+    }
+    void setVec4(const std::string &name, float x, float y, float z, float w)
+    {
+        glUniform4f(glGetUniformLocation(m_GLId, name.c_str()), x, y, z, w);
+    }
+    // ------------------------------------------------------------------------
+    void setMat2(const std::string &name, const glm::mat2 &mat) const
+    {
+        glUniformMatrix2fv(glGetUniformLocation(m_GLId, name.c_str()), 1, GL_FALSE, &mat[0][0]);
+    }
+    // ------------------------------------------------------------------------
+    void setMat3(const std::string &name, const glm::mat3 &mat) const
+    {
+        glUniformMatrix3fv(glGetUniformLocation(m_GLId, name.c_str()), 1, GL_FALSE, &mat[0][0]);
+    }
+    // ------------------------------------------------------------------------
+    void setMat4(const std::string &name, const glm::mat4 &mat) const
+    {
+        glUniformMatrix4fv(glGetUniformLocation(m_GLId, name.c_str()), 1, GL_FALSE, &mat[0][0]);
+    }
 };
 
 inline GLProgram buildProgram(std::initializer_list<GLShader> shaders)
@@ -257,3 +316,5 @@
   }
   return program;
 }
+
+
